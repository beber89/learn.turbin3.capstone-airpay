/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getAddressEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getProgramDerivedAddress,
  getStructDecoder,
  getStructEncoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type FixedSizeCodec,
  type FixedSizeDecoder,
  type FixedSizeEncoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type ReadonlyAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
  type WritableSignerAccount,
} from 'gill';
import { CAPSTONE_AIRPAY_Q3_PROGRAM_ADDRESS } from '../programs';
import {
  expectAddress,
  getAccountMetaFactory,
  type ResolvedAccount,
} from '../shared';

export const PAY_INVOICE_ITEM_DISCRIMINATOR = new Uint8Array([
  2, 69, 98, 193, 236, 146, 194, 133,
]);

export function getPayInvoiceItemDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    PAY_INVOICE_ITEM_DISCRIMINATOR
  );
}

export type PayInvoiceItemInstruction<
  TProgram extends string = typeof CAPSTONE_AIRPAY_Q3_PROGRAM_ADDRESS,
  TAccountUser extends string | AccountMeta<string> = string,
  TAccountInvoiceAccount extends string | AccountMeta<string> = string,
  TAccountInvoiceItemAccount extends string | AccountMeta<string> = string,
  TAccountMint extends string | AccountMeta<string> = string,
  TAccountUserAta extends string | AccountMeta<string> = string,
  TAccountMerchantVault extends string | AccountMeta<string> = string,
  TAccountFeeVault extends string | AccountMeta<string> = string,
  TAccountPaymentInvoiceMetadata extends string | AccountMeta<string> = string,
  TAccountTokenProgram extends
    | string
    | AccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',
  TAccountAssociatedTokenProgram extends
    | string
    | AccountMeta<string> = 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL',
  TAccountSystemProgram extends
    | string
    | AccountMeta<string> = '11111111111111111111111111111111',
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountUser extends string
        ? WritableSignerAccount<TAccountUser> & AccountSignerMeta<TAccountUser>
        : TAccountUser,
      TAccountInvoiceAccount extends string
        ? ReadonlyAccount<TAccountInvoiceAccount>
        : TAccountInvoiceAccount,
      TAccountInvoiceItemAccount extends string
        ? ReadonlyAccount<TAccountInvoiceItemAccount>
        : TAccountInvoiceItemAccount,
      TAccountMint extends string
        ? ReadonlyAccount<TAccountMint>
        : TAccountMint,
      TAccountUserAta extends string
        ? WritableAccount<TAccountUserAta>
        : TAccountUserAta,
      TAccountMerchantVault extends string
        ? WritableAccount<TAccountMerchantVault>
        : TAccountMerchantVault,
      TAccountFeeVault extends string
        ? WritableAccount<TAccountFeeVault>
        : TAccountFeeVault,
      TAccountPaymentInvoiceMetadata extends string
        ? WritableAccount<TAccountPaymentInvoiceMetadata>
        : TAccountPaymentInvoiceMetadata,
      TAccountTokenProgram extends string
        ? ReadonlyAccount<TAccountTokenProgram>
        : TAccountTokenProgram,
      TAccountAssociatedTokenProgram extends string
        ? ReadonlyAccount<TAccountAssociatedTokenProgram>
        : TAccountAssociatedTokenProgram,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      ...TRemainingAccounts,
    ]
  >;

export type PayInvoiceItemInstructionData = {
  discriminator: ReadonlyUint8Array;
  buyerMetadataHash: ReadonlyUint8Array;
};

export type PayInvoiceItemInstructionDataArgs = {
  buyerMetadataHash: ReadonlyUint8Array;
};

export function getPayInvoiceItemInstructionDataEncoder(): FixedSizeEncoder<PayInvoiceItemInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['buyerMetadataHash', fixEncoderSize(getBytesEncoder(), 32)],
    ]),
    (value) => ({ ...value, discriminator: PAY_INVOICE_ITEM_DISCRIMINATOR })
  );
}

export function getPayInvoiceItemInstructionDataDecoder(): FixedSizeDecoder<PayInvoiceItemInstructionData> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['buyerMetadataHash', fixDecoderSize(getBytesDecoder(), 32)],
  ]);
}

export function getPayInvoiceItemInstructionDataCodec(): FixedSizeCodec<
  PayInvoiceItemInstructionDataArgs,
  PayInvoiceItemInstructionData
> {
  return combineCodec(
    getPayInvoiceItemInstructionDataEncoder(),
    getPayInvoiceItemInstructionDataDecoder()
  );
}

export type PayInvoiceItemAsyncInput<
  TAccountUser extends string = string,
  TAccountInvoiceAccount extends string = string,
  TAccountInvoiceItemAccount extends string = string,
  TAccountMint extends string = string,
  TAccountUserAta extends string = string,
  TAccountMerchantVault extends string = string,
  TAccountFeeVault extends string = string,
  TAccountPaymentInvoiceMetadata extends string = string,
  TAccountTokenProgram extends string = string,
  TAccountAssociatedTokenProgram extends string = string,
  TAccountSystemProgram extends string = string,
> = {
  /** User is the buyer/payer of the invoice */
  user: TransactionSigner<TAccountUser>;
  /** invoice_account created by calling initialize_invoice_account by merchant */
  invoiceAccount: Address<TAccountInvoiceAccount>;
  invoiceItemAccount: Address<TAccountInvoiceItemAccount>;
  mint: Address<TAccountMint>;
  userAta?: Address<TAccountUserAta>;
  merchantVault: Address<TAccountMerchantVault>;
  feeVault: Address<TAccountFeeVault>;
  /**
   * User details are referenced on payment - e.g. address of user to deliver item to
   * The structure of metadata can be determined by merchant since it is saved on chain as a hash
   */
  paymentInvoiceMetadata: Address<TAccountPaymentInvoiceMetadata>;
  tokenProgram?: Address<TAccountTokenProgram>;
  associatedTokenProgram?: Address<TAccountAssociatedTokenProgram>;
  systemProgram?: Address<TAccountSystemProgram>;
  buyerMetadataHash: PayInvoiceItemInstructionDataArgs['buyerMetadataHash'];
};

export async function getPayInvoiceItemInstructionAsync<
  TAccountUser extends string,
  TAccountInvoiceAccount extends string,
  TAccountInvoiceItemAccount extends string,
  TAccountMint extends string,
  TAccountUserAta extends string,
  TAccountMerchantVault extends string,
  TAccountFeeVault extends string,
  TAccountPaymentInvoiceMetadata extends string,
  TAccountTokenProgram extends string,
  TAccountAssociatedTokenProgram extends string,
  TAccountSystemProgram extends string,
  TProgramAddress extends Address = typeof CAPSTONE_AIRPAY_Q3_PROGRAM_ADDRESS,
>(
  input: PayInvoiceItemAsyncInput<
    TAccountUser,
    TAccountInvoiceAccount,
    TAccountInvoiceItemAccount,
    TAccountMint,
    TAccountUserAta,
    TAccountMerchantVault,
    TAccountFeeVault,
    TAccountPaymentInvoiceMetadata,
    TAccountTokenProgram,
    TAccountAssociatedTokenProgram,
    TAccountSystemProgram
  >,
  config?: { programAddress?: TProgramAddress }
): Promise<
  PayInvoiceItemInstruction<
    TProgramAddress,
    TAccountUser,
    TAccountInvoiceAccount,
    TAccountInvoiceItemAccount,
    TAccountMint,
    TAccountUserAta,
    TAccountMerchantVault,
    TAccountFeeVault,
    TAccountPaymentInvoiceMetadata,
    TAccountTokenProgram,
    TAccountAssociatedTokenProgram,
    TAccountSystemProgram
  >
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? CAPSTONE_AIRPAY_Q3_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    user: { value: input.user ?? null, isWritable: true },
    invoiceAccount: { value: input.invoiceAccount ?? null, isWritable: false },
    invoiceItemAccount: {
      value: input.invoiceItemAccount ?? null,
      isWritable: false,
    },
    mint: { value: input.mint ?? null, isWritable: false },
    userAta: { value: input.userAta ?? null, isWritable: true },
    merchantVault: { value: input.merchantVault ?? null, isWritable: true },
    feeVault: { value: input.feeVault ?? null, isWritable: true },
    paymentInvoiceMetadata: {
      value: input.paymentInvoiceMetadata ?? null,
      isWritable: true,
    },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    associatedTokenProgram: {
      value: input.associatedTokenProgram ?? null,
      isWritable: false,
    },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;
  }
  if (!accounts.userAta.value) {
    accounts.userAta.value = await getProgramDerivedAddress({
      programAddress:
        'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address<'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'>,
      seeds: [
        getAddressEncoder().encode(expectAddress(accounts.user.value)),
        getAddressEncoder().encode(expectAddress(accounts.tokenProgram.value)),
        getAddressEncoder().encode(expectAddress(accounts.mint.value)),
      ],
    });
  }
  if (!accounts.associatedTokenProgram.value) {
    accounts.associatedTokenProgram.value =
      'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address<'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'>;
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  const instruction = {
    accounts: [
      getAccountMeta(accounts.user),
      getAccountMeta(accounts.invoiceAccount),
      getAccountMeta(accounts.invoiceItemAccount),
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.userAta),
      getAccountMeta(accounts.merchantVault),
      getAccountMeta(accounts.feeVault),
      getAccountMeta(accounts.paymentInvoiceMetadata),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.associatedTokenProgram),
      getAccountMeta(accounts.systemProgram),
    ],
    programAddress,
    data: getPayInvoiceItemInstructionDataEncoder().encode(
      args as PayInvoiceItemInstructionDataArgs
    ),
  } as PayInvoiceItemInstruction<
    TProgramAddress,
    TAccountUser,
    TAccountInvoiceAccount,
    TAccountInvoiceItemAccount,
    TAccountMint,
    TAccountUserAta,
    TAccountMerchantVault,
    TAccountFeeVault,
    TAccountPaymentInvoiceMetadata,
    TAccountTokenProgram,
    TAccountAssociatedTokenProgram,
    TAccountSystemProgram
  >;

  return instruction;
}

export type PayInvoiceItemInput<
  TAccountUser extends string = string,
  TAccountInvoiceAccount extends string = string,
  TAccountInvoiceItemAccount extends string = string,
  TAccountMint extends string = string,
  TAccountUserAta extends string = string,
  TAccountMerchantVault extends string = string,
  TAccountFeeVault extends string = string,
  TAccountPaymentInvoiceMetadata extends string = string,
  TAccountTokenProgram extends string = string,
  TAccountAssociatedTokenProgram extends string = string,
  TAccountSystemProgram extends string = string,
> = {
  /** User is the buyer/payer of the invoice */
  user: TransactionSigner<TAccountUser>;
  /** invoice_account created by calling initialize_invoice_account by merchant */
  invoiceAccount: Address<TAccountInvoiceAccount>;
  invoiceItemAccount: Address<TAccountInvoiceItemAccount>;
  mint: Address<TAccountMint>;
  userAta: Address<TAccountUserAta>;
  merchantVault: Address<TAccountMerchantVault>;
  feeVault: Address<TAccountFeeVault>;
  /**
   * User details are referenced on payment - e.g. address of user to deliver item to
   * The structure of metadata can be determined by merchant since it is saved on chain as a hash
   */
  paymentInvoiceMetadata: Address<TAccountPaymentInvoiceMetadata>;
  tokenProgram?: Address<TAccountTokenProgram>;
  associatedTokenProgram?: Address<TAccountAssociatedTokenProgram>;
  systemProgram?: Address<TAccountSystemProgram>;
  buyerMetadataHash: PayInvoiceItemInstructionDataArgs['buyerMetadataHash'];
};

export function getPayInvoiceItemInstruction<
  TAccountUser extends string,
  TAccountInvoiceAccount extends string,
  TAccountInvoiceItemAccount extends string,
  TAccountMint extends string,
  TAccountUserAta extends string,
  TAccountMerchantVault extends string,
  TAccountFeeVault extends string,
  TAccountPaymentInvoiceMetadata extends string,
  TAccountTokenProgram extends string,
  TAccountAssociatedTokenProgram extends string,
  TAccountSystemProgram extends string,
  TProgramAddress extends Address = typeof CAPSTONE_AIRPAY_Q3_PROGRAM_ADDRESS,
>(
  input: PayInvoiceItemInput<
    TAccountUser,
    TAccountInvoiceAccount,
    TAccountInvoiceItemAccount,
    TAccountMint,
    TAccountUserAta,
    TAccountMerchantVault,
    TAccountFeeVault,
    TAccountPaymentInvoiceMetadata,
    TAccountTokenProgram,
    TAccountAssociatedTokenProgram,
    TAccountSystemProgram
  >,
  config?: { programAddress?: TProgramAddress }
): PayInvoiceItemInstruction<
  TProgramAddress,
  TAccountUser,
  TAccountInvoiceAccount,
  TAccountInvoiceItemAccount,
  TAccountMint,
  TAccountUserAta,
  TAccountMerchantVault,
  TAccountFeeVault,
  TAccountPaymentInvoiceMetadata,
  TAccountTokenProgram,
  TAccountAssociatedTokenProgram,
  TAccountSystemProgram
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? CAPSTONE_AIRPAY_Q3_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    user: { value: input.user ?? null, isWritable: true },
    invoiceAccount: { value: input.invoiceAccount ?? null, isWritable: false },
    invoiceItemAccount: {
      value: input.invoiceItemAccount ?? null,
      isWritable: false,
    },
    mint: { value: input.mint ?? null, isWritable: false },
    userAta: { value: input.userAta ?? null, isWritable: true },
    merchantVault: { value: input.merchantVault ?? null, isWritable: true },
    feeVault: { value: input.feeVault ?? null, isWritable: true },
    paymentInvoiceMetadata: {
      value: input.paymentInvoiceMetadata ?? null,
      isWritable: true,
    },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    associatedTokenProgram: {
      value: input.associatedTokenProgram ?? null,
      isWritable: false,
    },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;
  }
  if (!accounts.associatedTokenProgram.value) {
    accounts.associatedTokenProgram.value =
      'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address<'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'>;
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  const instruction = {
    accounts: [
      getAccountMeta(accounts.user),
      getAccountMeta(accounts.invoiceAccount),
      getAccountMeta(accounts.invoiceItemAccount),
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.userAta),
      getAccountMeta(accounts.merchantVault),
      getAccountMeta(accounts.feeVault),
      getAccountMeta(accounts.paymentInvoiceMetadata),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.associatedTokenProgram),
      getAccountMeta(accounts.systemProgram),
    ],
    programAddress,
    data: getPayInvoiceItemInstructionDataEncoder().encode(
      args as PayInvoiceItemInstructionDataArgs
    ),
  } as PayInvoiceItemInstruction<
    TProgramAddress,
    TAccountUser,
    TAccountInvoiceAccount,
    TAccountInvoiceItemAccount,
    TAccountMint,
    TAccountUserAta,
    TAccountMerchantVault,
    TAccountFeeVault,
    TAccountPaymentInvoiceMetadata,
    TAccountTokenProgram,
    TAccountAssociatedTokenProgram,
    TAccountSystemProgram
  >;

  return instruction;
}

export type ParsedPayInvoiceItemInstruction<
  TProgram extends string = typeof CAPSTONE_AIRPAY_Q3_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    /** User is the buyer/payer of the invoice */
    user: TAccountMetas[0];
    /** invoice_account created by calling initialize_invoice_account by merchant */
    invoiceAccount: TAccountMetas[1];
    invoiceItemAccount: TAccountMetas[2];
    mint: TAccountMetas[3];
    userAta: TAccountMetas[4];
    merchantVault: TAccountMetas[5];
    feeVault: TAccountMetas[6];
    /**
     * User details are referenced on payment - e.g. address of user to deliver item to
     * The structure of metadata can be determined by merchant since it is saved on chain as a hash
     */

    paymentInvoiceMetadata: TAccountMetas[7];
    tokenProgram: TAccountMetas[8];
    associatedTokenProgram: TAccountMetas[9];
    systemProgram: TAccountMetas[10];
  };
  data: PayInvoiceItemInstructionData;
};

export function parsePayInvoiceItemInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>
): ParsedPayInvoiceItemInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 11) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts![accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      user: getNextAccount(),
      invoiceAccount: getNextAccount(),
      invoiceItemAccount: getNextAccount(),
      mint: getNextAccount(),
      userAta: getNextAccount(),
      merchantVault: getNextAccount(),
      feeVault: getNextAccount(),
      paymentInvoiceMetadata: getNextAccount(),
      tokenProgram: getNextAccount(),
      associatedTokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
    },
    data: getPayInvoiceItemInstructionDataDecoder().decode(instruction.data),
  };
}
